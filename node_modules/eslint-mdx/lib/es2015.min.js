import{parse as e}from"espree";import t from"path";import s from"remark-mdx";import n from"remark-parse";import r from"unified";const o=["@typescript-eslint/parser","babel-eslint"],i=["JSXElement","JSXFragment"],a=e=>i.includes(e.type),c=t=>{if(t){if("string"==typeof t&&(t=require(t)),"object"==typeof t&&(t="parseForESLint"in t&&t.parseForESLint||"parse"in t&&t.parse),"function"!=typeof t)throw new TypeError("Invalid custom parser for `eslint-mdx`: "+t);return[t]}const s=[e];for(const e of o)try{const t=require(e),n="parseForESLint"in t?t.parseForESLint:t.parse;n&&s.unshift(n)}catch(e){}return s},l=e=>{const t=e.start.offset,s=e.end.offset;return{range:[t,s],loc:Object.assign({},e),start:t,end:s}};function p(e,t,s){if(!e||!e.loc||!e.range)return e;Object.entries(e).forEach(([n,r])=>{r&&(Array.isArray(r)?e[n]=r.map(e=>p(e,t,s)):e[n]=p(r,t,s))});const{loc:{start:n,end:r},range:o}=e,i=o[0]+s,a=o[1]+s;return Object.assign(Object.assign({},e),{start:i,end:a,range:[i,a],loc:{start:{line:t+n.line,column:n.column},end:{line:t+r.line,column:r.column}}})}const u=e=>e&&e[0],h=e=>e&&e[e.length-1],m=(e,t)=>t.every(t=>t in e),f="(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*"+("(?:[^\"'=<>`\\u0000-\\u0020]+|'[^']*'|\"[^\"]*\"|"+"{.*}".replace(".","[\0-ï¿¿]")+")")+")?)",d="<[A-Za-z]*[A-Za-z0-9\\.\\-]*"+f+"*\\s*>",x="<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>",g="<[A-Za-z]*[A-Za-z0-9\\.\\-]*"+f+"*\\s*\\/?>",y="\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e",_="(\x3c!---*)",b="(-*--\x3e)",E="(\x3c!---*)([\\s\\S]*?)(-*--\x3e)",j=new RegExp(`^(?:${d})$`),S=new RegExp(`^(?:${x})$`),v=new RegExp(`^(?:${d+"[\\s\\S]*"+x})$`),w=new RegExp(`^(?:${g})$`),J=new RegExp(`^(?:${y})$`),N=new RegExp("(\x3c!---*)([\\s\\S]*?)(-*--\x3e)"),$=new RegExp("(\x3c!---*)([\\s\\S]*?)(-*--\x3e)","g"),A=e=>j.test(e),L=e=>S.test(e),z=e=>J.test(e),T=e=>v.test(e),F=e=>w.test(e);class O{constructor({code:e,enter:t}){this.code=e,this._enter=t}combineLeftJsxNodes(e){const t=e[0].position.start,s=h(e).position.end;return{type:"jsx",data:e[0].data,value:this.code.slice(t.offset,s.offset),position:{start:e[0].position.start,end:h(e).position.end}}}combineJsxNodes(e,t){let s=0;const n=[],{length:r}=e;return e.reduce((e,o,i)=>{if("jsx"===o.type){const r=o.value;if(A(r))s++,n.push(o);else{if(L(r))s--,n.push(o);else if(z(r)||F(r)||T(r))n.push(o);else try{const e=B.normalizeJsxNode(o,t);n.push(...Array.isArray(e)?e:[e])}catch(e){const{start:t}=o.position;throw Object.assign(new SyntaxError("unknown jsx node: "+JSON.stringify(r)),{lineNumber:t.line,column:t.column,index:t.offset})}if(!s){const t=n.findIndex(e=>A(e.value));-1===t?e.push(...n):(e.push(...n.slice(0,t)),e.push(this.combineLeftJsxNodes(n.slice(t)))),n.length=0}}}else s?n.push(o):e.push(o);return i===r-1&&n.length>0&&e.push(this.combineLeftJsxNodes(n)),e},[])}traverse(e,t){if(!e)return;let s=e.children;if(s){const t=e;s=e.children=this.combineJsxNodes(s,t),s.forEach(e=>this.traverse(e,t))}this._enter(e,t)}}const k=(e,t)=>new O(t).traverse(e),P=r().use(n).freeze(),Z=P().use(s).freeze(),R=["body","comments","tokens"],X=["export","import","jsx"],C=["column","lineNumber"],H=[".mdx"],M=[".md"],W={comment:!0,ecmaFeatures:{jsx:!0},ecmaVersion:(new Date).getUTCFullYear(),sourceType:"module",tokens:!0,filePath:"__placeholder__.mdx",loc:!0,range:!0},q="<$>".length;class I{constructor(){this._options=W,this.parse=this.parse.bind(this),this.parseForESLint=this.parseForESLint.bind(this)}normalizeJsxNode(e,t,s=this._options){const n=e.value;if("jsx"!==e.type||z(n))return e;if(N.exec(n)){const s=[],{position:{start:{line:r,column:o,offset:i}}}=e;Object.assign(e,{data:Object.assign(Object.assign({},e.data),{jsxType:"JSXElementWithHTMLComments",comments:s,inline:!!t&&"root"!==t.type}),value:n.replace($,(e,t,a,c,l)=>{const p=l+e.length,u=n.slice(0,l).split("\n"),m=n.slice(0,p).split("\n"),f=`{/${"*".repeat(t.length-2)}${a}${"*".repeat(c.length-2)}/}`,d=u.length-1,x=m.length-1;return s.push({fixed:f,loc:{start:{line:r+d,column:h(u).length+(d?0:o-1),offset:i+l},end:{line:r+x,column:h(m).length+(x?0:o-1),offset:i+p}},origin:e}),f})})}return this._normalizeJsxNodes(e,s)}parse(e,t){return this.parseForESLint(e,t).ast}parseForESLint(e,s){const n=t.extname(s.filePath),r=H.concat(s.extensions||[]).includes(n),o=M.concat(s.markdownExtensions||[]).includes(n);if(!r&&!o)return this._eslintParse(e,s);const i=(r?Z:P).parse(e);return this._ast=Object.assign(Object.assign({},l(i.position)),{type:"Program",sourceType:s.sourceType||"module",body:[],comments:[],tokens:[]}),this._services={JSXElementsWithHTMLComments:[]},r&&k(i,{code:e,enter:(e,t)=>{if(!X.includes(e.type))return;let n=this.normalizeJsxNode(e,t,s);n=Array.isArray(n)?n:[n],n.forEach(e=>this._nodeToAst(e,s))}}),{ast:this._ast,services:this._services}}_eslintParse(e,t){let s,n;this._parsers&&t.parser===this._options.parser||(this._parsers=c(t.parser)),t.filePath&&this._options!==t&&Object.assign(this._options,t);for(const t of this._parsers)try{s=t(e,this._options);break}catch(e){n||(n=e)}if(!s&&n)throw n;return"ast"in s&&s.ast?s:{ast:s}}_normalizeJsxNodes(e,t){const s=e.value;let n;try{n=this._eslintParse(`<$>${s}</$>`,t).ast}catch(t){if(m(t,C)){const{position:{start:s}}=e;throw"index"in t?t.index+=s.offset-q:"pos"in t&&(t.pos+=s.offset-q),t.column=t.lineNumber>1?t.column:t.column+s.column-q,t.lineNumber+=s.line-1,t}return e}const{expression:r}=n.body[0];if(!a(r)||r.children.length<=1)return e;const{position:{start:{line:o,offset:i}}}=e;return r.children.reduce((t,n)=>{if(!a(n))return t;const{start:r,end:c,loc:{start:l,end:p}={start:{column:r,line:1},end:{column:c,line:1}},range:u=[r,c]}=n,h=o+l.line-1,m=o+p.line-1,f=u[0]-q,d=u[1]-q;return t.push({type:"jsx",data:t.length>0?null:e.data,value:s.slice(f,d),position:{start:{line:h,column:o===h?l.column-q:l.column,offset:i+f},end:{line:m,column:o===h?p.column-q:p.column,offset:i+d}}}),t},[])}_nodeToAst(e,t){e.data&&"JSXElementWithHTMLComments"===e.data.jsxType&&this._services.JSXElementsWithHTMLComments.push(e);const s=e.value,{loc:n,start:r,end:o}=l(e.position);if(z(s)){const e=N.exec(s)[2];return void this._ast.comments.push({type:"Block",value:e,loc:n,range:[r,o]})}const i=n.start.line-1;let a;try{a=this._eslintParse(s,t).ast}catch(e){throw m(e,C)&&(e.index+=r,e.column=e.lineNumber>1?e.column:e.column+n.start.column,e.lineNumber+=i),e}const c=r-a.range[0];R.forEach(e=>this._ast[e].push(...a[e].map(e=>p(e,i,c))))}}const B=new I,{parse:D,parseForESLint:U}=B;export{R as AST_PROPS,S as CLOSE_TAG_REGEX,N as COMMENT_CONTENT_REGEX,$ as COMMENT_CONTENT_REGEX_GLOBAL,J as COMMENT_REGEX,H as DEFAULT_EXTENSIONS,W as DEFAULT_PARSER_OPTIONS,X as ES_NODE_TYPES,o as FALLBACK_PARSERS,i as JSX_TYPES,C as LOC_ERROR_PROPERTIES,M as MARKDOWN_EXTENSIONS,v as OPEN_CLOSE_TAG_REGEX,j as OPEN_TAG_REGEX,I as Parser,w as SELF_CLOSING_TAG_REGEX,O as Traverse,x as closeTag,y as comment,b as commentClose,E as commentContent,_ as commentOpen,u as first,m as hasProperties,L as isCloseTag,z as isComment,a as isJsxNode,T as isOpenCloseTag,A as isOpenTag,F as isSelfClosingTag,h as last,P as mdProcessor,Z as mdxProcessor,c as normalizeParser,l as normalizePosition,d as openTag,D as parse,U as parseForESLint,B as parser,p as restoreNodeLocation,g as selfClosingTag,k as traverse};
