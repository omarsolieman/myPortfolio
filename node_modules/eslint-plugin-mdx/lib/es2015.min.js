import{version as e}from"eslint/package.json";import{JSX_TYPES as t,isJsxNode as r,openTag as s,DEFAULT_EXTENSIONS as n,MARKDOWN_EXTENSIONS as o}from"eslint-mdx";import i from"eslint-plugin-react/lib/rules/no-unescaped-entities";import a from"eslint/lib/rules/no-unused-expressions";import c from"path";import l from"vfile";import{cosmiconfigSync as m}from"cosmiconfig";import p from"remark-mdx";import u from"remark-parse";import d from"remark-stringify";import f from"unified";const g={parser:"eslint-mdx",plugins:["mdx"]},x=(e,t={})=>(Array.isArray(e)?e:Object.keys(e)).reduce((e,t)=>Object.assign(e,{[t]:!1}),t);let h;try{h=require("rebass")}catch(e){h=["Box","Flex","Text","Heading","Link","Button","Image","Card"]}const b=Object.assign(Object.assign({},g),{globals:x(h,{React:!1}),rules:{"lines-between-class-members":0,"react/jsx-no-undef":[2,{allowGlobals:!0}],"react/react-in-jsx-scope":0}}),j=+e.split(".").slice(0,2).join("."),y=Object.assign(Object.assign({},g),{rules:{"mdx/no-jsx-html-comments":2,"mdx/no-unescaped-entities":1,"mdx/no-unused-expressions":2,"mdx/remark":1,"no-unused-expressions":0,"react/no-unescaped-entities":0}});if(j>=6.4){const e=[{files:"*.mdx",extends:"plugin:mdx/overrides"}];try{require.resolve("prettier"),require.resolve("eslint-plugin-prettier"),e.push({files:"*.md",rules:{"prettier/prettier":[2,{parser:"markdown"}]}})}catch(e){}Object.assign(y,{overrides:e})}var k=Object.freeze({__proto__:null,base:g,overrides:b,recommended:y});const v={meta:{type:"problem",docs:{description:"Forbid invalid html style comments in jsx block",category:"SyntaxError",recommended:!0},messages:{jsxHtmlComments:"html style comments are invalid in jsx: {{ origin }}"},fixable:"code"},create:e=>({ExpressionStatement(r){const s=e.parserServices.JSXElementsWithHTMLComments;if(!t.includes(r.expression.type)||"Program"!==r.parent.type||!s||0===s.length)return;const n=s.shift();if(n.data.inline)return;n.data.comments.forEach(({fixed:t,loc:s,origin:n})=>e.report({messageId:"jsxHtmlComments",data:{origin:n},loc:s,node:r,fix:e=>e.replaceTextRange([s.start.offset,s.end.offset],t)}))}})},O=[{char:">",alternatives:["&gt;"]},{char:'"',alternatives:["&quot;","&ldquo;","&#34;","&rdquo;"]},{char:"'",alternatives:["&apos;","&lsquo;","&#39;","&rsquo;"]},{char:"}",alternatives:["&#125;"]}],S=Object.assign(Object.assign({},i),{create(e){const t=(e.options[0]||{}).forbid||O;return{"Literal, JSXText"(n){let{parent:o}=n;if(!r(o))return;for(;o&&"Program"!==o.parent.type;)o=o.parent;const{start:{line:i,column:a},end:{line:c,column:l}}=n.loc,{lines:m}=e.getSourceCode();let p=o.loc.start.line<i?0:m.slice(i-1,c).join("\n").search(s);p<0&&(p=0);for(let r=i;r<=c;r++){let s=m[r-1],o=0,u=s.length;r===i&&(o=a+p),r===c&&(u=l,r===i&&(u+=p)),s=s.slice(o,u),t.forEach(t=>{for(let i=0;i<s.length;i++){const a=s[i];"string"==typeof t?a===t&&e.report({loc:{line:r,column:o+i},message:`HTML entity, \`${t}\` , must be escaped.`,node:n}):a===t.char&&e.report({loc:{line:r,column:o+i},message:`\`${t.char}\` can be escaped with ${t.alternatives.map(e=>"``".split("").join(e)).join(", ")}.`,node:n})}})}}}}}),q=Object.assign(Object.assign({},a),{create(e){const t=a.create(e);return{ExpressionStatement(e){r(e.expression)&&"Program"===e.parent.type||t.ExpressionStatement(e)}}}}),E=(e,t,r)=>{r&&/^\.\.?([/\\]|$)/.test(e)&&(e=c.resolve(c.dirname(r),e)),t=t.endsWith("-")?t:t+"-";const s=[e,e.startsWith("@")?e.replace("/","/"+t):t+e];let n;for(const e of s)try{return require(e)}catch(e){n||(n=e)}throw n};let w,C;const I=(e,t)=>{w||(w=m("remark",{packageProp:"remarkConfig"}).search),C||(C=f().use(u).freeze());const{config:r,filepath:s}=w(e)||{},{plugins:n=[],settings:o}=r||{};try{n.push([require.resolve("remark-lint-file-extension"),!1])}catch(e){}const i=C().use({settings:o}).use(d);return t&&i.use(p),n.reduce((e,t)=>{const[r,...n]=Array.isArray(t)?t:[t];return e.use("string"==typeof r?E(r,"remark",s):r,...n)},i).freeze()},T={meta:{type:"layout",docs:{description:"Linter integration with remark plugins",category:"Stylistic Issues",recommended:!0},messages:{remarkReport:"{{ source }}:{{ ruleId }} - {{ reason }}"},fixable:"code"},create(e){const t=e.getFilename(),r=c.extname(t),s=e.getSourceCode(),i=e.parserOptions,a=n.concat(i.extensions||[]).includes(r),m=o.concat(i.markdownExtensions||[]).includes(r);return{Program(r){if(!a&&!m)return;const n=s.getText(r),o=I(t,a),i=l({path:t,contents:n});try{o.processSync(i)}catch(e){i.messages.includes(e)||(i.message(e).fatal=!0)}i.messages.forEach(({source:t,reason:s,ruleId:i,location:{start:a,end:c}})=>e.report({messageId:"remarkReport",data:{reason:s,source:t,ruleId:i},loc:{start:Object.assign(Object.assign({},a),{column:a.column-1}),end:Object.assign(Object.assign({},c),{column:c.column-1})},node:r,fix(e){if(null==a.offset)return null;const t=[a.offset,null==c.offset?a.offset+1:c.offset],r=n.slice(...t),s=o.processSync(r).toString();return e.replaceTextRange(t,r.endsWith("\n")?s:s.slice(0,-1))}}))}}}},H={"no-jsx-html-comments":v,"no-unescaped-entities":S,"no-unused-expressions":q,remark:T};export{k as configs,x as getGlobals,I as getRemarkProcessor,v as noJsxHtmlComments,S as noUnescapedEntities,q as noUnusedExpressions,T as remark,E as requirePkg,H as rules};
